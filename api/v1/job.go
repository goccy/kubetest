//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"fmt"

	"github.com/goccy/kubejob"
	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/client-go/rest"
)

type PreInitCallback func(JobExecutor) error

type Job interface {
	PreInit(corev1.Container, PreInitCallback)
	RunWithExecutionHandler(context.Context, func([]JobExecutor) error) error
}

type JobExecutor interface {
	ExecOnly() ([]byte, error)
	ExecAsync()
	Stop() error
	CopyFromPod(string, string) error
	CopyToPod(string, string) error
	Container() corev1.Container
	Pod() *corev1.Pod
}

type JobBuilder struct {
	cfg       *rest.Config
	namespace string
	dryRun    bool
}

func NewJobBuilder(cfg *rest.Config, namesapce string, dryRun bool) *JobBuilder {
	return &JobBuilder{dryRun: dryRun}
}

func (b *JobBuilder) BuildWithJob(jobSpec *batchv1.Job) (Job, error) {
	if b.dryRun {
		return &mockJob{job: jobSpec}, nil
	}
	job, err := kubejob.NewJobBuilder(b.cfg, b.namespace).BuildWithJob(jobSpec)
	if err != nil {
		return nil, err
	}
	return &wrappedKubejob{job: job}, nil
}

type wrappedKubejob struct {
	job *kubejob.Job
}

func (j *wrappedKubejob) PreInit(c corev1.Container, cb PreInitCallback) {
	j.job.PreInit(c, func(exec *kubejob.JobExecutor) error {
		return cb(&wrappedJobExecutor{exec: exec})
	})
}

func (j *wrappedKubejob) RunWithExecutionHandler(ctx context.Context, handler func([]JobExecutor) error) error {
	return j.job.RunWithExecutionHandler(ctx, func(execs []*kubejob.JobExecutor) error {
		converted := make([]JobExecutor, 0, len(execs))
		for _, exec := range execs {
			converted = append(converted, &wrappedJobExecutor{exec: exec})
		}
		return handler(converted)
	})
}

type wrappedJobExecutor struct {
	exec *kubejob.JobExecutor
}

func (e *wrappedJobExecutor) ExecOnly() ([]byte, error) {
	return e.exec.ExecOnly()
}

func (e *wrappedJobExecutor) ExecAsync() {
	e.exec.ExecAsync()
}

func (e *wrappedJobExecutor) Stop() error {
	return e.exec.Stop()
}

func (e *wrappedJobExecutor) CopyFromPod(src string, dst string) error {
	return e.exec.CopyFromPod(src, dst)
}

func (e *wrappedJobExecutor) CopyToPod(src string, dst string) error {
	return e.exec.CopyToPod(src, dst)
}

func (e *wrappedJobExecutor) Container() corev1.Container {
	return e.exec.Container
}

func (e *wrappedJobExecutor) Pod() *corev1.Pod {
	return e.exec.Pod
}

type mockJob struct {
	job *batchv1.Job
}

func (j *mockJob) PreInit(c corev1.Container, cb PreInitCallback) {}

func (j *mockJob) RunWithExecutionHandler(ctx context.Context, handler func([]JobExecutor) error) error {
	execs := make([]JobExecutor, 0, len(j.job.Spec.Template.Spec.Containers))
	for _, container := range j.job.Spec.Template.Spec.Containers {
		execs = append(execs, &mockJobExecutor{
			container: container,
		})
	}
	return handler(execs)
}

type mockJobExecutor struct {
	container corev1.Container
}

func (e *mockJobExecutor) ExecOnly() ([]byte, error) {
	return nil, nil
}

func (e *mockJobExecutor) ExecAsync() {
}

func (e *mockJobExecutor) Stop() error {
	return nil
}

func (e *mockJobExecutor) CopyFromPod(src string, dst string) error {
	fmt.Printf("copy from %s to %s\n", src, dst)
	return nil
}

func (e *mockJobExecutor) CopyToPod(src string, dst string) error {
	fmt.Printf("copy from %s to %s\n", src, dst)
	return nil
}

func (e *mockJobExecutor) Container() corev1.Container {
	return e.container
}

func (e *mockJobExecutor) Pod() *corev1.Pod {
	return &corev1.Pod{}
}
