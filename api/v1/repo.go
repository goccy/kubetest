//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"fmt"
	"os"
	"strings"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/transport"
	"github.com/go-git/go-git/v5/plumbing/transport/http"
)

type RepositoryManager struct {
	repos       []RepositorySpec
	tokenMgr    *TokenManager
	clonedPaths map[string]string
}

func NewRepositoryManager(repos []RepositorySpec, tokenMgr *TokenManager) *RepositoryManager {
	return &RepositoryManager{
		repos:       repos,
		tokenMgr:    tokenMgr,
		clonedPaths: map[string]string{},
	}
}

func (m *RepositoryManager) Cleanup() error {
	errs := []string{}
	for name, clonedPath := range m.clonedPaths {
		if err := os.RemoveAll(clonedPath); err != nil {
			errs = append(errs, fmt.Sprintf("failed to remove %s repository directory: %s", name, err.Error()))
		}
	}
	if len(errs) > 0 {
		return fmt.Errorf("kubetest: failed to cleanup %s", strings.Join(errs, ":"))
	}
	return nil
}

func (m *RepositoryManager) CloneAll(ctx context.Context) error {
	for _, repo := range m.repos {
		dir, err := os.MkdirTemp("", "repo")
		if err != nil {
			return fmt.Errorf("kubetest: failed to create temporary directory for repository: %w", err)
		}
		if err := m.clone(ctx, dir, repo.Value); err != nil {
			return err
		}
		m.clonedPaths[repo.Name] = dir
	}
	return nil
}

func (m *RepositoryManager) clone(ctx context.Context, clonedPath string, repo Repository) error {
	const (
		defaultBaseBranchName = "master"
		defaultRemoteName     = "origin"
	)

	if err := os.MkdirAll(clonedPath, 0755); err != nil {
		return fmt.Errorf("kubetest: failed to create directory %s for repository: %w", clonedPath, err)
	}
	var auth transport.AuthMethod
	if repo.Token != "" {
		token, err := m.tokenMgr.TokenByName(ctx, repo.Token)
		if err != nil {
			return err
		}
		auth = &http.BasicAuth{
			Password: token.Value,
		}
	}
	gitRepo, err := git.PlainCloneContext(ctx, clonedPath, false, &git.CloneOptions{
		URL:  repo.URL,
		Auth: auth,
	})
	if err != nil {
		return fmt.Errorf("kubetest: failed to clone repository: %w", err)
	}
	cfg, err := gitRepo.Config()
	if err != nil {
		return fmt.Errorf("kubetest: failed to get repository config: %w", err)
	}
	var remote string
	if len(cfg.Remotes) == 1 {
		for name := range cfg.Remotes {
			remote = name
			break
		}
	} else {
		remote = defaultRemoteName
	}
	var baseBranch string
	if cfg.Init.DefaultBranch != "" {
		baseBranch = cfg.Init.DefaultBranch
	} else if len(cfg.Branches) == 1 {
		for name := range cfg.Branches {
			baseBranch = name
			break
		}
	} else {
		baseBranch = defaultBaseBranchName
	}
	tree, err := gitRepo.Worktree()
	if err != nil {
		return fmt.Errorf("kubetest: failed to get worktree from repository: %w", err)
	}
	checkoutOpt := &git.CheckoutOptions{}
	switch {
	case repo.Branch != "":
		checkoutOpt.Branch = plumbing.NewRemoteReferenceName(remote, repo.Branch)
	case repo.Rev != "":
		checkoutOpt.Create = true
		checkoutOpt.Branch = plumbing.NewBranchReferenceName(repo.Rev)
		checkoutOpt.Hash = plumbing.NewHash(repo.Rev)
	}
	if err := checkoutOpt.Validate(); err != nil {
		return fmt.Errorf("kubetest: invalid checkout option: %w", err)
	}
	if err := tree.Checkout(checkoutOpt); err != nil {
		return fmt.Errorf("kubetest: failed to checkout: %w", err)
	}
	if repo.Merge != nil {
		if repo.Merge.Base != "" {
			baseBranch = repo.Merge.Base
		}
		if err := tree.PullContext(ctx, &git.PullOptions{
			ReferenceName: plumbing.NewBranchReferenceName(baseBranch),
			SingleBranch:  true,
		}); err != nil && err != git.NoErrAlreadyUpToDate {
			return fmt.Errorf("kubetest: failed to merge base branch: %w", err)
		}
	}
	return nil
}

func (m *RepositoryManager) ClonedPathByRepoName(name string) (string, error) {
	path, exists := m.clonedPaths[name]
	if !exists {
		return "", errInvalidRepoName(name)
	}
	return path, nil
}
