//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"fmt"
	"io"
	"strings"
	"sync"
)

type LogLevel int

const (
	LogLevelNone LogLevel = iota
	LogLevelError
	LogLevelWarn
	LogLevelInfo
	LogLevelDebug
)

func (l LogLevel) String() string {
	switch l {
	case LogLevelNone:
		return "none"
	case LogLevelWarn:
		return "warn"
	case LogLevelInfo:
		return "info"
	case LogLevelDebug:
		return "debug"
	}
	return ""
}

type Logger interface {
	Log(format string, args ...interface{})
	Debug(format string, args ...interface{})
	Info(format string, args ...interface{})
	Warn(format string, args ...interface{})
	Error(format string, args ...interface{})
	AddMask(mask string)
	Group() Logger
	LogGroup(group Logger)
}

type mainLogger struct {
	masks  []string
	level  LogLevel
	out    io.Writer
	maskMu sync.RWMutex
	logMu  sync.Mutex
}

type loggerKey struct{}

func WithLogger(ctx context.Context, logger Logger) context.Context {
	return context.WithValue(ctx, loggerKey{}, logger)
}

func LoggerFromContext(ctx context.Context) Logger {
	return ctx.Value(loggerKey{}).(Logger)
}

func NewLogger(out io.Writer, level LogLevel) Logger {
	return &mainLogger{
		level: level,
		out:   out,
	}
}

func (l *mainLogger) AddMask(mask string) {
	l.maskMu.Lock()
	l.masks = append(l.masks, mask)
	l.maskMu.Unlock()
}

func (l *mainLogger) Group() Logger {
	return &groupLogger{
		level: l.level,
	}
}

type groupLogger struct {
	level LogLevel
	msgs  []string
}

func (g *groupLogger) AddMask(mask string) {}
func (g *groupLogger) Group() Logger {
	return &groupLogger{
		level: g.level,
	}
}

func (g *groupLogger) LogGroup(group Logger) {
	subgroup, ok := group.(*groupLogger)
	if !ok {
		return
	}
	g.msgs = append(g.msgs, subgroup.msgs...)
}

func (g *groupLogger) Log(format string, args ...interface{}) {
	g.log(format, args...)
}

func (g *groupLogger) Debug(format string, args ...interface{}) {
	if g.level < LogLevelDebug {
		return
	}
	g.log("[DEBUG] "+format, args...)
}

func (g *groupLogger) Info(format string, args ...interface{}) {
	if g.level < LogLevelInfo {
		return
	}
	g.log("[INFO] "+format, args...)
}

func (g *groupLogger) Warn(format string, args ...interface{}) {
	if g.level < LogLevelWarn {
		return
	}
	g.log("[WARN] "+format, args...)
}

func (g *groupLogger) Error(format string, args ...interface{}) {
	if g.level < LogLevelError {
		return
	}
	g.log("[ERROR] "+format, args...)
}

func (g *groupLogger) log(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	if msg == "" {
		return
	}
	g.msgs = append(g.msgs, msg)
}

func (g *groupLogger) buf() string {
	return strings.Join(g.msgs, "\n")
}

func (l *mainLogger) LogGroup(group Logger) {
	g, ok := group.(*groupLogger)
	if !ok {
		return
	}
	l.log(g.buf())
}

func (l *mainLogger) Log(format string, args ...interface{}) {
	l.log(format, args...)
}

func (l *mainLogger) Debug(format string, args ...interface{}) {
	if l.level < LogLevelDebug {
		return
	}
	l.log("[DEBUG] "+format, args...)
}

func (l *mainLogger) Info(format string, args ...interface{}) {
	if l.level < LogLevelInfo {
		return
	}
	l.log("[INFO] "+format, args...)
}

func (l *mainLogger) Warn(format string, args ...interface{}) {
	if l.level < LogLevelWarn {
		return
	}
	l.log("[WARN] "+format, args...)
}

func (l *mainLogger) Error(format string, args ...interface{}) {
	if l.level < LogLevelError {
		return
	}
	l.log("[ERROR] "+format, args...)
}

func (l *mainLogger) log(format string, args ...interface{}) {
	l.logMu.Lock()
	defer l.logMu.Unlock()
	msg := fmt.Sprintf(format, args...)
	if msg == "" {
		return
	}
	fmt.Fprintln(l.out, l.mask(msg))
}

func (l *mainLogger) mask(msg string) string {
	l.maskMu.RLock()
	defer l.maskMu.RUnlock()
	maskedMsg := msg
	for _, m := range l.masks {
		genMaskText := strings.Repeat("*", len(m))
		maskedMsg = strings.Replace(maskedMsg, m, genMaskText, -1)
	}
	return maskedMsg
}
