//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"fmt"
	"io"
	"strings"
	"sync"
)

type LogLevel int

const (
	LogLevelNone LogLevel = iota
	LogLevelError
	LogLevelWarn
	LogLevelInfo
	LogLevelDebug
)

func (l LogLevel) String() string {
	switch l {
	case LogLevelNone:
		return "none"
	case LogLevelWarn:
		return "warn"
	case LogLevelInfo:
		return "info"
	case LogLevelDebug:
		return "debug"
	}
	return ""
}

type Logger struct {
	masks  []string
	level  LogLevel
	out    io.Writer
	maskMu sync.RWMutex
	logMu  sync.Mutex
}

type loggerKey struct{}

func WithLogger(ctx context.Context, logger *Logger) context.Context {
	return context.WithValue(ctx, loggerKey{}, logger)
}

func LoggerFromContext(ctx context.Context) *Logger {
	return ctx.Value(loggerKey{}).(*Logger)
}

func NewLogger(out io.Writer, level LogLevel) *Logger {
	return &Logger{
		level: level,
		out:   out,
	}
}

func (l *Logger) AddMask(mask string) {
	l.maskMu.Lock()
	l.masks = append(l.masks, mask)
	l.maskMu.Unlock()
}

func (l *Logger) Group() *LoggerGroup {
	return &LoggerGroup{
		level: l.level,
	}
}

type LoggerGroup struct {
	level LogLevel
	msgs  []string
}

func (g *LoggerGroup) Log(format string, args ...interface{}) {
	g.log(format, args...)
}

func (g *LoggerGroup) Debug(format string, args ...interface{}) {
	if g.level < LogLevelDebug {
		return
	}
	g.log("[DEBUG] "+format, args...)
}

func (g *LoggerGroup) Info(format string, args ...interface{}) {
	if g.level < LogLevelInfo {
		return
	}
	g.log("[INFO] "+format, args...)
}

func (g *LoggerGroup) Warn(format string, args ...interface{}) {
	if g.level < LogLevelWarn {
		return
	}
	g.log("[WARN] "+format, args...)
}

func (g *LoggerGroup) Error(format string, args ...interface{}) {
	if g.level < LogLevelError {
		return
	}
	g.log("[ERROR] "+format, args...)
}

func (g *LoggerGroup) log(format string, args ...interface{}) {
	msg := fmt.Sprintf(format, args...)
	if msg == "" {
		return
	}
	g.msgs = append(g.msgs, msg)
}

func (g *LoggerGroup) buf() string {
	return strings.Join(g.msgs, "\n")
}

func (l *Logger) LogGroup(group *LoggerGroup) {
	l.log(group.buf())
}

func (l *Logger) Log(format string, args ...interface{}) {
	l.log(format, args...)
}

func (l *Logger) Debug(format string, args ...interface{}) {
	if l.level < LogLevelDebug {
		return
	}
	l.log("[DEBUG] "+format, args...)
}

func (l *Logger) Info(format string, args ...interface{}) {
	if l.level < LogLevelInfo {
		return
	}
	l.log("[INFO] "+format, args...)
}

func (l *Logger) Warn(format string, args ...interface{}) {
	if l.level < LogLevelWarn {
		return
	}
	l.log("[WARN] "+format, args...)
}

func (l *Logger) Error(format string, args ...interface{}) {
	if l.level < LogLevelError {
		return
	}
	l.log("[ERROR] "+format, args...)
}

func (l *Logger) log(format string, args ...interface{}) {
	l.logMu.Lock()
	defer l.logMu.Unlock()
	msg := fmt.Sprintf(format, args...)
	if msg == "" {
		return
	}
	fmt.Fprintln(l.out, l.mask(msg))
}

func (l *Logger) mask(msg string) string {
	l.maskMu.RLock()
	defer l.maskMu.RUnlock()
	maskedMsg := msg
	for _, m := range l.masks {
		genMaskText := strings.Repeat("*", len(m))
		maskedMsg = strings.Replace(maskedMsg, m, genMaskText, -1)
	}
	return maskedMsg
}
