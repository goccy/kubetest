//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"strings"
	"sync"
)

type Logger interface {
	Log(msg string)
	Debug(format string, args ...interface{})
	Info(format string, args ...interface{})
	Warn(format string, args ...interface{})
	Error(format string, args ...interface{})
	AddMask(mask string)
	Group() Logger
	LogGroup(group Logger)
}

type mainLogger struct {
	masks  []string
	level  LogLevel
	out    io.Writer
	buf    *bytes.Buffer
	maskMu sync.RWMutex
	logMu  sync.Mutex
}

type loggerKey struct{}

func WithLogger(ctx context.Context, logger Logger) context.Context {
	return context.WithValue(ctx, loggerKey{}, logger)
}

func LoggerFromContext(ctx context.Context) Logger {
	return ctx.Value(loggerKey{}).(Logger)
}

func NewLogger(out io.Writer, level LogLevel) Logger {
	return &mainLogger{
		level: level,
		out:   out,
		buf:   bytes.NewBuffer([]byte{}),
	}
}

func (l *mainLogger) AddMask(mask string) {
	l.maskMu.Lock()
	l.masks = append(l.masks, mask)
	l.maskMu.Unlock()
}

func (l *mainLogger) Group() Logger {
	return &groupLogger{
		level: l.level,
	}
}

type groupLogger struct {
	level LogLevel
	msgs  []string
}

func (g *groupLogger) AddMask(mask string) {}
func (g *groupLogger) Group() Logger {
	return &groupLogger{
		level: g.level,
	}
}

func (g *groupLogger) LogGroup(group Logger) {
	subgroup, ok := group.(*groupLogger)
	if !ok {
		return
	}
	g.msgs = append(g.msgs, subgroup.msgs...)
}

func (g *groupLogger) Log(msg string) {
	g.log(msg)
}

func (g *groupLogger) Debug(format string, args ...interface{}) {
	if g.level < LogLevelDebug {
		return
	}
	g.log("[DEBUG] " + fmt.Sprintf(format, args...))
}

func (g *groupLogger) Info(format string, args ...interface{}) {
	if g.level < LogLevelInfo {
		return
	}
	g.log("[INFO] " + fmt.Sprintf(format, args...))
}

func (g *groupLogger) Warn(format string, args ...interface{}) {
	if g.level < LogLevelWarn {
		return
	}
	g.log("[WARN] " + fmt.Sprintf(format, args...))
}

func (g *groupLogger) Error(format string, args ...interface{}) {
	if g.level < LogLevelError {
		return
	}
	g.log("[ERROR] " + fmt.Sprintf(format, args...))
}

func (g *groupLogger) log(msg string) {
	if msg == "" {
		return
	}
	g.msgs = append(g.msgs, msg)
}

func (g *groupLogger) buf() string {
	return strings.Join(g.msgs, "\n")
}

func (l *mainLogger) LogGroup(group Logger) {
	g, ok := group.(*groupLogger)
	if !ok {
		return
	}
	l.log(g.buf())
}

func (l *mainLogger) Log(msg string) {
	l.log(msg)
}

func (l *mainLogger) Debug(format string, args ...interface{}) {
	if l.level < LogLevelDebug {
		return
	}
	l.log("[DEBUG] " + fmt.Sprintf(format, args...))
}

func (l *mainLogger) Info(format string, args ...interface{}) {
	if l.level < LogLevelInfo {
		return
	}
	l.log("[INFO] " + fmt.Sprintf(format, args...))
}

func (l *mainLogger) Warn(format string, args ...interface{}) {
	if l.level < LogLevelWarn {
		return
	}
	l.log("[WARN] " + fmt.Sprintf(format, args...))
}

func (l *mainLogger) Error(format string, args ...interface{}) {
	if l.level < LogLevelError {
		return
	}
	l.log("[ERROR] " + fmt.Sprintf(format, args...))
}

func (l *mainLogger) log(msg string) {
	if msg == "" {
		return
	}
	l.logMu.Lock()
	defer l.logMu.Unlock()
	maskedMsg := l.mask(msg)
	fmt.Fprintln(l.out, maskedMsg)
	fmt.Fprintln(l.buf, maskedMsg)
}

func (l *mainLogger) mask(msg string) string {
	l.maskMu.RLock()
	defer l.maskMu.RUnlock()
	maskedMsg := msg
	for _, m := range l.masks {
		genMaskText := strings.Repeat("*", len(m))
		maskedMsg = strings.Replace(maskedMsg, m, genMaskText, -1)
	}
	return maskedMsg
}
