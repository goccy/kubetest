//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"encoding/json"
	"fmt"
	"path/filepath"

	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/client-go/rest"
)

const (
	kubetestLabel  = "kubetest.io/testjob"
	keysAnnotation = "kubetest.io/strategyKeys"
)

type TaskBuilder struct {
	cfg       *rest.Config
	mgr       *ResourceManager
	namespace string
	runMode   RunMode
}

func NewTaskBuilder(cfg *rest.Config, mgr *ResourceManager, namespace string, runMode RunMode) *TaskBuilder {
	return &TaskBuilder{
		cfg:       cfg,
		mgr:       mgr,
		namespace: namespace,
		runMode:   runMode,
	}
}

func (b *TaskBuilder) Build(spec TestJobTemplateSpec) (*Task, error) {
	return b.BuildWithKey(spec, nil)
}

func (b *TaskBuilder) BuildWithKey(tmpl TestJobTemplateSpec, strategyKey *StrategyKey) (*Task, error) {
	spec := tmpl.Spec
	ctx := NewTaskBuildContextWithSpec(spec)
	podSpec := ctx.spec
	mainContainer, err := getMainContainerFromTmpl(tmpl)
	if err != nil {
		return nil, err
	}
	if mainContainer.Name == "" {
		return nil, fmt.Errorf("kubetest: main container name must be specified")
	}
	var onFinishSubTask func(*SubTask)
	if strategyKey != nil {
		onFinishSubTask = strategyKey.OnFinishSubTask
		containers := []corev1.Container{}
		for _, key := range strategyKey.Keys {
			container := mainContainer
			container.Name = ""
			container.Env = append(container.Env, corev1.EnvVar{
				Name:  strategyKey.Env,
				Value: key,
			})
			containers = append(containers, container)
		}
		sideCarContainers := []corev1.Container{}
		for _, container := range podSpec.Containers {
			if container.Name == mainContainer.Name {
				continue
			}
			sideCarContainers = append(sideCarContainers, container)
		}
		podSpec.Containers = append(sideCarContainers, containers...)
	}
	podMeta := tmpl.ObjectMeta
	labels := map[string]string{}
	for k, v := range podMeta.Labels {
		labels[k] = v
	}
	labels[kubetestLabel] = fmt.Sprint(true)
	annotations := map[string]string{}
	for k, v := range podMeta.Annotations {
		annotations[k] = v
	}
	if strategyKey != nil {
		keys, err := json.Marshal(strategyKey.Keys)
		if err != nil {
			return nil, fmt.Errorf("kubetest: failed to encode strategy keys: %w", err)
		}
		annotations[keysAnnotation] = string(keys)
	}
	podMeta.Labels = labels
	podMeta.Annotations = annotations
	job, err := NewJobBuilder(b.cfg, b.namespace, b.runMode).BuildWithJob(&batchv1.Job{
		ObjectMeta: tmpl.ObjectMeta,
		Spec: batchv1.JobSpec{
			Template: corev1.PodTemplateSpec{
				ObjectMeta: podMeta,
				Spec:       podSpec,
			},
		},
	})
	if err != nil {
		return nil, err
	}
	callback, err := b.preInitCallback(ctx)
	if err != nil {
		return nil, err
	}
	job.PreInit(b.preInitContainer(ctx), callback)
	b.mgr.artifactMgr.AddArtifacts(spec.Artifacts)
	artifactMap := map[string]ArtifactSpec{}
	for _, artifact := range spec.Artifacts {
		artifactMap[artifact.Container.Name] = artifact
	}
	copyArtifact := func(ctx context.Context, exec JobExecutor) error {
		artifact, exists := artifactMap[exec.Container().Name]
		if !exists {
			return nil
		}
		localPath, err := b.mgr.artifactMgr.LocalPathByName(artifact.Name)
		if err != nil {
			return err
		}
		return exec.CopyFrom(
			ctx,
			artifact.Container.Path,
			localPath,
		)
	}
	return &Task{
		OnFinishSubTask:        onFinishSubTask,
		job:                    job,
		copyArtifact:           copyArtifact,
		artifactContainerNames: artifactMap,
		strategyKey:            strategyKey,
		mainContainerName:      mainContainer.Name,
	}, nil
}

func (b *TaskBuilder) preInitContainer(ctx *TaskBuildContext) corev1.Container {
	return corev1.Container{
		Name:         "preinit",
		Image:        ctx.preInitImage,
		Command:      []string{"echo"},
		Args:         []string{"-n", "preinit"},
		VolumeMounts: ctx.preInitVolumeMounts,
	}
}

func (b *TaskBuilder) preInitCallback(ctx *TaskBuildContext) (PreInitCallback, error) {
	type copyPath struct {
		src string
		dst string
	}

	copyPaths := []*copyPath{}
	if err := b.getCopyPathForRepository(ctx, func(src, dst string) {
		copyPaths = append(copyPaths, &copyPath{src: src, dst: dst})
	}); err != nil {
		return nil, err
	}
	if err := b.getCopyPathForToken(ctx, func(src, dst string) {
		copyPaths = append(copyPaths, &copyPath{src: src, dst: dst})
	}); err != nil {
		return nil, err
	}
	if err := b.getCopyPathForArtifact(ctx, func(src, dst string) {
		copyPaths = append(copyPaths, &copyPath{src: src, dst: dst})
	}); err != nil {
		return nil, err
	}
	return func(ctx context.Context, exec JobExecutor) error {
		for _, path := range copyPaths {
			if err := exec.CopyTo(ctx, path.src, path.dst); err != nil {
				return err
			}
		}
		return nil
	}, nil
}

func (b *TaskBuilder) getCopyPathForRepository(ctx *TaskBuildContext, cb func(src, dst string)) error {
	for name, dst := range ctx.repoToPath {
		src, err := b.mgr.RepositoryPathByName(name)
		if err != nil {
			return err
		}
		cb(src, dst)
	}
	return nil
}

func (b *TaskBuilder) getCopyPathForToken(ctx *TaskBuildContext, cb func(src, dst string)) error {
	for name, dst := range ctx.tokenToPath {
		src, err := b.mgr.TokenPathByName(context.Background(), name)
		if err != nil {
			return err
		}
		cb(src, dst)
	}
	return nil
}

func (b *TaskBuilder) getCopyPathForArtifact(ctx *TaskBuildContext, cb func(src, dst string)) error {
	for name, dst := range ctx.artifactToPath {
		src, err := b.mgr.ArtifactPathByName(name)
		if err != nil {
			return err
		}
		cb(src, dst)
	}
	return nil
}

type TaskBuildContext struct {
	spec                corev1.PodSpec
	preInitImage        string
	preInitVolumeMounts []corev1.VolumeMount
	repoToPath          map[string]string
	artifactToPath      map[string]string
	tokenToPath         map[string]string
}

func NewTaskBuildContextWithSpec(spec TestJobPodSpec) *TaskBuildContext {
	ctx := &TaskBuildContext{
		repoToPath:     map[string]string{},
		artifactToPath: map[string]string{},
		tokenToPath:    map[string]string{},
	}
	for _, volume := range spec.Volumes {
		name := volume.Name
		switch {
		case volume.Repo != nil:
			path := filepath.Join("/", "tmp", "repo", name)
			ctx.repoToPath[volume.Repo.Name] = path
			spec.PodSpec.Volumes = append(spec.PodSpec.Volumes, corev1.Volume{
				Name: name,
				VolumeSource: corev1.VolumeSource{
					EmptyDir: &corev1.EmptyDirVolumeSource{},
				},
			})
			ctx.preInitVolumeMounts = append(ctx.preInitVolumeMounts, corev1.VolumeMount{
				Name:      name,
				MountPath: path,
			})
		case volume.Artifact != nil:
			path := filepath.Join("/", "tmp", "artifact", name)
			ctx.artifactToPath[volume.Artifact.Name] = path
			spec.PodSpec.Volumes = append(spec.PodSpec.Volumes, corev1.Volume{
				Name: name,
				VolumeSource: corev1.VolumeSource{
					EmptyDir: &corev1.EmptyDirVolumeSource{},
				},
			})
			ctx.preInitVolumeMounts = append(ctx.preInitVolumeMounts, corev1.VolumeMount{
				Name:      name,
				MountPath: path,
			})
		case volume.Token != nil:
			path := filepath.Join("/", "tmp", "token", name)
			ctx.tokenToPath[volume.Token.Name] = path
			spec.PodSpec.Volumes = append(spec.PodSpec.Volumes, corev1.Volume{
				Name: name,
				VolumeSource: corev1.VolumeSource{
					EmptyDir: &corev1.EmptyDirVolumeSource{},
				},
			})
			ctx.preInitVolumeMounts = append(ctx.preInitVolumeMounts, corev1.VolumeMount{
				Name:      name,
				MountPath: path,
			})
		}
	}
	setPreInitImage(ctx, spec)
	ctx.spec = spec.PodSpec
	return ctx
}

func setPreInitImage(ctx *TaskBuildContext, spec TestJobPodSpec) {
	if len(ctx.preInitVolumeMounts) == 0 {
		// no pre-initialization process required
		return
	}
	mountName := ctx.preInitVolumeMounts[0].Name
	for _, container := range spec.InitContainers {
		for _, volumeMount := range container.VolumeMounts {
			if volumeMount.Name == mountName {
				ctx.preInitImage = container.Image
				return
			}
		}
	}
	for _, container := range spec.Containers {
		for _, volumeMount := range container.VolumeMounts {
			if volumeMount.Name == mountName {
				ctx.preInitImage = container.Image
				return
			}
		}
	}
}
