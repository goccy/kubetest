//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

type RunMode int

const (
	RunModeKubernetes RunMode = iota
	RunModeLocal
	RunModeDryRun
)

func (m RunMode) String() string {
	switch m {
	case RunModeKubernetes:
		return "kubernetes"
	case RunModeLocal:
		return "local"
	case RunModeDryRun:
		return "dryrun"
	}
	return "unknown"
}

type Runner struct {
	cfg       *rest.Config
	clientset *kubernetes.Clientset
	runMode   RunMode
	logger    Logger
}

func NewRunner(cfg *rest.Config, runMode RunMode) *Runner {
	return &Runner{
		cfg:     cfg,
		runMode: runMode,
	}
}

func (r *Runner) SetLogger(logger Logger) {
	r.logger = logger
}

func (r *Runner) Run(ctx context.Context, testjob TestJob) (*Result, error) {
	if err := testjob.Validate(); err != nil {
		return nil, err
	}
	startedAt := time.Now()
	if r.logger == nil {
		r.logger = NewLogger(os.Stdout, LogLevelInfo)
	}
	ctx = WithLogger(ctx, r.logger)
	clientset, err := kubernetes.NewForConfig(r.cfg)
	if err != nil {
		return nil, err
	}
	resourceMgr := NewResourceManager(clientset, testjob)
	if err := resourceMgr.Setup(ctx); err != nil {
		return nil, err
	}
	defer resourceMgr.Cleanup()
	builder := NewTaskBuilder(r.cfg, resourceMgr, testjob.Namespace, r.runMode)
	var result Result
	for _, step := range testjob.Spec.PreSteps {
		r.logger.Info("run prestep: %s", step.Name)
		task, err := builder.Build(ctx, step.Template)
		if err != nil {
			return nil, err
		}
		preStepResult, err := task.Run(ctx)
		if err != nil {
			return nil, fmt.Errorf("kubetest: failed to run prestep %s: %w", step.Name, err)
		}
		for _, result := range preStepResult.MainTaskResults() {
			if err := result.Error(); err != nil {
				return nil, fmt.Errorf("kubetest: failed to run %s: %w", step.Name, err)
			}
		}
		result.preStepResults = append(result.preStepResults, preStepResult)
	}
	scheduler := NewTaskScheduler(testjob.Spec.Strategy, builder)
	taskGroup, err := scheduler.Schedule(ctx, testjob.Spec.Template)
	if err != nil {
		return nil, err
	}
	taskResult, err := taskGroup.Run(ctx)
	if err != nil {
		return nil, err
	}
	if err := resourceMgr.ExportArtifacts(ctx); err != nil {
		return nil, err
	}
	result.Status = taskResult.Status()
	result.TotalNum = taskResult.TotalNum()
	result.SuccessNum = taskResult.SuccessNum()
	result.FailureNum = taskResult.FailureNum()
	if result.TotalNum != (result.SuccessNum + result.FailureNum) {
		result.Status = ResultStatusError
		result.UnknownNum = result.TotalNum - (result.SuccessNum + result.FailureNum)
	}
	result.taskResult = taskResult
	result.StartedAt = startedAt
	result.ElapsedTime = time.Since(startedAt)
	return &result, nil
}

type ResultStatus int

const (
	ResultStatusSuccess ResultStatus = iota
	ResultStatusFailure
	ResultStatusError
)

func (s ResultStatus) String() string {
	switch s {
	case ResultStatusSuccess:
		return "success"
	case ResultStatusFailure:
		return "failure"
	}
	return "error"
}

func (s ResultStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf(`"%s"`, s.String())), nil
}

type Result struct {
	Status         ResultStatus
	StartedAt      time.Time
	ElapsedTime    time.Duration
	TotalNum       int
	SuccessNum     int
	FailureNum     int
	UnknownNum     int
	preStepResults []*TaskResult
	taskResult     *TaskResultGroup
	job            TestJob
}

func (r *Result) MarshalJSON() ([]byte, error) {
	b, err := json.Marshal(struct {
		Status         ResultStatus     `json:"status"`
		TotalNum       int              `json:"totalNum"`
		SuccessNum     int              `json:"successNum"`
		FailureNum     int              `json:"failureNum"`
		UnknownNum     int              `json:"unknownNum,omitempty"`
		StartedAt      time.Time        `json:"startedAt"`
		ElapsedTimeSec int64            `json:"elapsedTimeSec"`
		Details        *TaskResultGroup `json:"details"`
	}{
		Status:         r.Status,
		TotalNum:       r.TotalNum,
		SuccessNum:     r.SuccessNum,
		FailureNum:     r.FailureNum,
		UnknownNum:     r.UnknownNum,
		StartedAt:      r.StartedAt,
		ElapsedTimeSec: int64(r.ElapsedTime.Seconds()),
		Details:        r.taskResult,
	})
	if err != nil {
		return nil, err
	}
	var logMap map[string]interface{}
	if err := json.Unmarshal(b, &logMap); err != nil {
		return nil, err
	}
	for k, v := range r.job.Spec.Log.ExtParam {
		logMap[k] = v
	}
	return json.Marshal(logMap)
}
