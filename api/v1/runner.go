//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"os"

	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

type Runner struct {
	cfg       *rest.Config
	clientset *kubernetes.Clientset
	dryRun    bool
	logger    *Logger
}

func NewRunner(cfg *rest.Config, dryRun bool) *Runner {
	return &Runner{
		cfg:    cfg,
		dryRun: dryRun,
	}
}

func (r *Runner) SetLogger(logger *Logger) {
	r.logger = logger
}

func (r *Runner) Run(ctx context.Context, testjob TestJob) (*Result, error) {
	if r.logger == nil {
		r.logger = NewLogger(os.Stdout, LogLevelInfo)
	}
	ctx = WithLogger(ctx, r.logger)
	clientset, err := kubernetes.NewForConfig(r.cfg)
	if err != nil {
		return nil, err
	}
	resourceMgr := NewResourceManager(clientset, testjob)
	if err := resourceMgr.Setup(ctx); err != nil {
		return nil, err
	}
	defer resourceMgr.Cleanup()
	builder := NewTaskBuilder(r.cfg, resourceMgr, testjob.Namespace, r.dryRun)
	var result Result
	for _, step := range testjob.Spec.PreSteps {
		task, err := builder.Build(step.Template)
		if err != nil {
			return nil, err
		}
		preStepResult, err := task.Run(ctx)
		if err != nil {
			return nil, err
		}
		result.preStepResults = append(result.preStepResults, preStepResult)
	}
	scheduler := NewTaskScheduler(testjob.Spec.Strategy, builder)
	taskGroup, err := scheduler.Schedule(ctx, testjob.Spec.Template)
	if err != nil {
		return nil, err
	}
	taskResult, err := taskGroup.Run(ctx)
	if err != nil {
		return nil, err
	}
	result.taskResult = taskResult
	// copy final artifact
	return &result, nil
}

type Result struct {
	preStepResults []*TaskResult
	taskResult     *TaskResultGroup
}
