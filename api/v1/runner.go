//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

type RunMode int

const (
	RunModeKubernetes RunMode = iota
	RunModeLocal
	RunModeDryRun
)

func (m RunMode) String() string {
	switch m {
	case RunModeKubernetes:
		return "kubernetes"
	case RunModeLocal:
		return "local"
	case RunModeDryRun:
		return "dryrun"
	}
	return "unknown"
}

type Runner struct {
	cfg       *rest.Config
	clientset *kubernetes.Clientset
	runMode   RunMode
	logger    Logger
}

func NewRunner(cfg *rest.Config, runMode RunMode) *Runner {
	return &Runner{
		cfg:     cfg,
		runMode: runMode,
	}
}

func (r *Runner) SetLogger(logger Logger) {
	r.logger = logger
}

func (r *Runner) Run(ctx context.Context, testjob TestJob) (*Result, error) {
	if r.logger == nil {
		r.logger = NewLogger(os.Stdout, LogLevelInfo)
	}
	r.logger.Info("start kubetest")
	r.logger.Debug("run validation")
	if err := testjob.Validate(); err != nil {
		return nil, err
	}
	startedAt := time.Now()
	ctx = WithLogger(ctx, r.logger)
	clientset, err := kubernetes.NewForConfig(r.cfg)
	if err != nil {
		return nil, err
	}
	resourceMgr := NewResourceManager(clientset, testjob)
	r.logger.Debug("setup resource manager")
	if err := resourceMgr.Setup(ctx); err != nil {
		return nil, err
	}
	defer resourceMgr.Cleanup()
	builder := NewTaskBuilder(r.cfg, resourceMgr, testjob.Namespace, r.runMode)
	var result Result
	for _, step := range testjob.Spec.PreSteps {
		step := step
		r.logger.Info("run prestep: %s", step.Name)
		task, err := builder.Build(ctx, &step)
		if err != nil {
			return nil, err
		}
		preStepResult, err := task.Run(ctx)
		if err != nil {
			return nil, fmt.Errorf("kubetest: failed to run prestep %s: %w", step.Name, err)
		}
		for _, result := range preStepResult.MainTaskResults() {
			if err := result.Error(); err != nil {
				return nil, fmt.Errorf("kubetest: failed to run prestep %s: %w", step.Name, err)
			}
		}
		result.preStepResults = append(result.preStepResults, preStepResult)
	}
	scheduler := NewTaskScheduler(testjob.Spec.MainStep)
	taskGroup, err := scheduler.Schedule(ctx, builder)
	if err != nil {
		return nil, err
	}
	taskResult, err := taskGroup.Run(ctx)
	if err != nil {
		return nil, err
	}
	result.setByTaskResult(startedAt, taskResult)
	if err := resourceMgr.WriteLog(r.logger); err != nil {
		return nil, err
	}
	if err := resourceMgr.WriteReport(&result); err != nil {
		return nil, err
	}
	for _, step := range testjob.Spec.PostSteps {
		step := step
		r.logger.Info("run poststep: %s", step.Name)
		task, err := builder.Build(ctx, &step)
		if err != nil {
			return nil, err
		}
		postStepResult, err := task.Run(ctx)
		if err != nil {
			return nil, fmt.Errorf("kubetest: failed to run poststep %s: %w", step.Name, err)
		}
		for _, result := range postStepResult.MainTaskResults() {
			if err := result.Error(); err != nil {
				return nil, fmt.Errorf("kubetest: failed to run poststep %s: %w", step.Name, err)
			}
		}
		result.postStepResults = append(result.postStepResults, postStepResult)
	}
	if err := resourceMgr.ExportArtifacts(ctx); err != nil {
		return nil, err
	}
	return &result, nil
}

type ResultStatus int

const (
	ResultStatusSuccess ResultStatus = iota
	ResultStatusFailure
	ResultStatusError
)

func (s ResultStatus) String() string {
	switch s {
	case ResultStatusSuccess:
		return "success"
	case ResultStatusFailure:
		return "failure"
	}
	return "error"
}

func (s ResultStatus) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf(`"%s"`, s.String())), nil
}

type Result struct {
	Status          ResultStatus
	StartedAt       time.Time
	ElapsedTime     time.Duration
	TotalNum        int
	SuccessNum      int
	FailureNum      int
	UnknownNum      int
	preStepResults  []*TaskResult
	postStepResults []*TaskResult
	taskResult      *TaskResultGroup
	job             TestJob
}

func (r *Result) setByTaskResult(startedAt time.Time, taskResult *TaskResultGroup) {
	r.StartedAt = startedAt
	r.Status = taskResult.Status()
	r.TotalNum = taskResult.TotalNum()
	r.SuccessNum = taskResult.SuccessNum()
	r.FailureNum = taskResult.FailureNum()
	if r.TotalNum != (r.SuccessNum + r.FailureNum) {
		r.Status = ResultStatusError
		r.UnknownNum = r.TotalNum - (r.SuccessNum + r.FailureNum)
	}
	r.taskResult = taskResult
	r.ElapsedTime = time.Since(startedAt)
}

func (r *Result) MarshalJSON() ([]byte, error) {
	b, err := json.Marshal(struct {
		Status         ResultStatus     `json:"status"`
		TotalNum       int              `json:"totalNum"`
		SuccessNum     int              `json:"successNum"`
		FailureNum     int              `json:"failureNum"`
		UnknownNum     int              `json:"unknownNum,omitempty"`
		StartedAt      time.Time        `json:"startedAt"`
		ElapsedTimeSec int64            `json:"elapsedTimeSec"`
		Details        *TaskResultGroup `json:"details"`
	}{
		Status:         r.Status,
		TotalNum:       r.TotalNum,
		SuccessNum:     r.SuccessNum,
		FailureNum:     r.FailureNum,
		UnknownNum:     r.UnknownNum,
		StartedAt:      r.StartedAt,
		ElapsedTimeSec: int64(r.ElapsedTime.Seconds()),
		Details:        r.taskResult,
	})
	if err != nil {
		return nil, err
	}
	var logMap map[string]interface{}
	if err := json.Unmarshal(b, &logMap); err != nil {
		return nil, err
	}
	for k, v := range r.job.Spec.Log.ExtParam {
		logMap[k] = v
	}
	return json.Marshal(logMap)
}
