//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"fmt"
	"os"
	"time"

	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

type RunMode int

const (
	RunModeKubernetes RunMode = iota
	RunModeLocal
	RunModeDryRun
)

func (m RunMode) String() string {
	switch m {
	case RunModeKubernetes:
		return "kubernetes"
	case RunModeLocal:
		return "local"
	case RunModeDryRun:
		return "dryrun"
	}
	return "unknown"
}

type Runner struct {
	cfg       *rest.Config
	clientset *kubernetes.Clientset
	runMode   RunMode
	logger    Logger
}

func NewRunner(cfg *rest.Config, runMode RunMode) *Runner {
	return &Runner{
		cfg:     cfg,
		runMode: runMode,
	}
}

func (r *Runner) SetLogger(logger Logger) {
	r.logger = logger
}

func (r *Runner) Run(ctx context.Context, testjob TestJob) (*Report, error) {
	if err := testjob.Validate(); err != nil {
		return nil, err
	}
	if r.logger == nil {
		level := LogLevelInfo
		if testjob.Spec.Log.Level != LogLevelNone {
			level = testjob.Spec.Log.Level
		}
		r.logger = NewLogger(os.Stdout, level)
	}
	r.logger.Info("start kubetest")
	r.logger.Debug("run validation")
	startedAt := time.Now()
	ctx = WithLogger(ctx, r.logger)
	clientset, err := kubernetes.NewForConfig(r.cfg)
	if err != nil {
		return nil, err
	}
	resourceMgr := NewResourceManager(clientset, testjob)
	r.logger.Debug("setup resource manager")
	if err := resourceMgr.Setup(ctx); err != nil {
		return nil, err
	}
	defer resourceMgr.Cleanup()
	builder := NewTaskBuilder(r.cfg, resourceMgr, testjob.Namespace, r.runMode)
	var result Result
	for _, step := range testjob.Spec.PreSteps {
		step := step
		r.logger.Info("run prestep: %s", step.Name)
		task, err := builder.Build(ctx, &step)
		if err != nil {
			return nil, err
		}
		preStepResult, err := task.Run(ctx)
		if err != nil {
			return nil, fmt.Errorf("kubetest: failed to run prestep %s: %w", step.Name, err)
		}
		for _, result := range preStepResult.MainTaskResults() {
			if err := result.Error(); err != nil {
				return nil, fmt.Errorf("kubetest: failed to run prestep %s: %w", step.Name, err)
			}
		}
		result.preStepResults = append(result.preStepResults, preStepResult)
	}
	scheduler := NewTaskScheduler(testjob.Spec.MainStep)
	taskGroup, err := scheduler.Schedule(ctx, builder)
	if err != nil {
		return nil, err
	}
	taskResult, err := taskGroup.Run(ctx)
	if err != nil {
		return nil, err
	}
	result.setByTaskResult(startedAt, taskResult)
	if err := resourceMgr.WriteLog(r.logger); err != nil {
		return nil, err
	}
	if err := resourceMgr.WriteReport(&result); err != nil {
		return nil, err
	}
	for _, step := range testjob.Spec.PostSteps {
		step := step
		r.logger.Info("run poststep: %s", step.Name)
		task, err := builder.Build(ctx, &step)
		if err != nil {
			return nil, err
		}
		postStepResult, err := task.Run(ctx)
		if err != nil {
			return nil, fmt.Errorf("kubetest: failed to run poststep %s: %w", step.Name, err)
		}
		for _, result := range postStepResult.MainTaskResults() {
			if err := result.Error(); err != nil {
				return nil, fmt.Errorf("kubetest: failed to run poststep %s: %w", step.Name, err)
			}
		}
		result.postStepResults = append(result.postStepResults, postStepResult)
	}
	if err := resourceMgr.ExportArtifacts(ctx); err != nil {
		return nil, err
	}
	return result.toReport(), nil
}

type Result struct {
	status          ResultStatus
	startedAt       time.Time
	elapsedTime     time.Duration
	totalNum        int
	successNum      int
	failureNum      int
	unknownNum      int
	preStepResults  []*TaskResult
	postStepResults []*TaskResult
	taskResult      *TaskResultGroup
	job             TestJob
}

func (r *Result) setByTaskResult(startedAt time.Time, taskResult *TaskResultGroup) {
	r.startedAt = startedAt
	r.status = taskResult.Status()
	r.totalNum = taskResult.TotalNum()
	r.successNum = taskResult.SuccessNum()
	r.failureNum = taskResult.FailureNum()
	if r.totalNum != (r.successNum + r.failureNum) {
		r.status = ResultStatusError
		r.unknownNum = r.totalNum - (r.successNum + r.failureNum)
	}
	r.taskResult = taskResult
	r.elapsedTime = time.Since(startedAt)
}

func (r *Result) toReport() *Report {
	return &Report{
		Status:         r.status,
		TotalNum:       r.totalNum,
		SuccessNum:     r.successNum,
		FailureNum:     r.failureNum,
		UnknownNum:     r.unknownNum,
		StartedAt:      r.startedAt,
		ElapsedTimeSec: int64(r.elapsedTime.Seconds()),
		Details:        r.taskResult.ToReportDetails(),
		ExtParam:       r.job.Spec.Log.ExtParam,
	}
}
