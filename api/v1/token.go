//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/bradleyfalzon/ghinstallation"
	"github.com/google/go-github/v29/github"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

type Token struct {
	File  string
	Value string
}

type TokenManager struct {
	tokenMap map[string]TokenSource
	cli      *TokenClient
}

func NewTokenManager(tokens []TokenSpec, cli *TokenClient) *TokenManager {
	tokenMap := map[string]TokenSource{}
	for _, token := range tokens {
		tokenMap[token.Name] = token.Value
	}
	return &TokenManager{
		tokenMap: tokenMap,
		cli:      cli,
	}
}

func (m *TokenManager) TokenByName(ctx context.Context, name string) (*Token, error) {
	dir, err := os.MkdirTemp("", "token")
	if err != nil {
		return nil, fmt.Errorf("kubetest: failed to create temporary directory for token: %w", err)
	}

	source, exists := m.tokenMap[name]
	if !exists {
		return nil, fmt.Errorf("kubetest: failed to find token name %s", name)
	}
	value, err := m.cli.AccessToken(ctx, source)
	if err != nil {
		return nil, err
	}
	file := filepath.Join(dir, "token")
	if err := os.WriteFile(file, []byte(value), 0666); err != nil {
		return nil, fmt.Errorf("kubetest: failed to write token to %s: %w", file, err)
	}
	LoggerFromContext(ctx).AddMask(value)
	return &Token{
		File:  file,
		Value: value,
	}, nil
}

type TokenClient struct {
	clientset *kubernetes.Clientset
	namespace string
}

func NewTokenClient(clientset *kubernetes.Clientset, namespace string) *TokenClient {
	return &TokenClient{
		clientset: clientset,
		namespace: namespace,
	}
}

func (c *TokenClient) AccessToken(ctx context.Context, token TokenSource) (string, error) {
	switch {
	case token.GitHubApp != nil:
		return c.tokenFromGitHubApp(ctx, token.GitHubApp)
	case token.GitHubToken != nil:
		return c.tokenFromGitHubToken(ctx, token.GitHubToken)
	}
	return "", nil
}

func (c *TokenClient) tokenFromGitHubToken(ctx context.Context, source *GitHubTokenSource) (string, error) {
	secret, err := c.clientset.CoreV1().
		Secrets(c.namespace).
		Get(ctx, source.Name, metav1.GetOptions{})
	if err != nil {
		return "", fmt.Errorf("kubetest: failed to read secret for token by %s: %w", source.Name, err)
	}
	data, exists := secret.Data[source.Key]
	if !exists {
		return "", fmt.Errorf("kubetest: failed to find token data: %s", source.Key)
	}
	return strings.TrimSpace(string(data)), nil
}

func (c *TokenClient) tokenFromGitHubApp(ctx context.Context, source *GitHubAppTokenSource) (string, error) {
	if err := NewValidator().ValidateGitHubAppTokenSource(source); err != nil {
		return "", err
	}
	privateKey, err := c.clientset.CoreV1().
		Secrets(c.namespace).
		Get(ctx, source.KeyFile.Name, metav1.GetOptions{})
	if err != nil {
		return "", fmt.Errorf("kubetest: failed to read private key from secret %s: %w", source.KeyFile.Name, err)
	}
	privateKeyData, exists := privateKey.Data[source.KeyFile.Key]
	if !exists {
		return "", fmt.Errorf("kubetest: failed to find private key data: %s", source.KeyFile.Key)
	}
	token, err := c.tokenFromGitHubAppWithParam(ctx, source.AppID, source.InstallationID, source.Organization, privateKeyData)
	if err != nil {
		return "", fmt.Errorf("kubetset: failed to get token from github app params: %w", err)
	}
	return token, nil
}

func (c *TokenClient) tokenFromGitHubAppWithParam(ctx context.Context, appID, installationID int64, org string, privateKey []byte) (string, error) {
	appsTransport, err := ghinstallation.NewAppsTransport(http.DefaultTransport, appID, privateKey)
	if err != nil {
		return "", fmt.Errorf("failed to initialize apps transport from %d: %w", appID, err)
	}
	githubClient := github.NewClient(&http.Client{Transport: appsTransport})
	if installationID == 0 {
		id, err := c.getInstallationID(ctx, githubClient, org)
		if err != nil {
			return "", fmt.Errorf("failed to get installation id by %s: %w", org, err)
		}
		installationID = id
	}
	token, _, err := githubClient.Apps.CreateInstallationToken(ctx, installationID, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create installation token: %w", err)
	}
	return token.GetToken(), nil
}

func (c *TokenClient) getInstallationID(ctx context.Context, githubClient *github.Client, org string) (int64, error) {
	opt := &github.ListOptions{
		PerPage: 100,
		Page:    1,
	}
	for {
		ins, resp, err := githubClient.Apps.ListInstallations(ctx, opt)
		if err != nil {
			return 0, fmt.Errorf("failed to fetch installations: %w", err)
		}
		for _, in := range ins {
			if org == in.GetAccount().GetLogin() {
				return in.GetID(), nil
			}
		}
		if resp.LastPage == 0 || opt.Page == resp.LastPage {
			return 0, fmt.Errorf("failed to find %s in installations", org)
		}
		opt.Page++
	}
}
