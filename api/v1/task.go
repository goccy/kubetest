//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"

	"github.com/goccy/kubejob"
	"golang.org/x/sync/errgroup"
	corev1 "k8s.io/api/core/v1"
)

type Task struct {
	job                    *kubejob.Job
	artifactContainerNames map[string]ArtifactSpec
	copyArtifact           func(*kubejob.JobExecutor) error
	strategyKey            *StrategyKey
}

func (t *Task) Run(ctx context.Context) error {
	return t.job.RunWithExecutionHandler(ctx, func(executors []*kubejob.JobExecutor) error {
		for _, sidecar := range t.sideCarExecutors(executors) {
			sidecar.ExecAsync()
		}
		subTasks := t.getSubTasks(t.mainExecutors(executors))
		for _, subTaskGroup := range t.strategyKey.SubTaskScheduler.Schedule(subTasks) {
			if err := subTaskGroup.Run(ctx); err != nil {
				return err
			}
		}
		return nil
	})
}

func (t *Task) getSubTasks(execs []*kubejob.JobExecutor) []*SubTask {
	tasks := make([]*SubTask, 0, len(execs))
	for _, exec := range execs {
		tasks = append(tasks, &SubTask{
			exec:         exec,
			hasArtifact:  t.hasArtifact(exec.Container),
			copyArtifact: t.copyArtifact,
		})
	}
	return tasks
}

func (t *Task) mainExecutors(executors []*kubejob.JobExecutor) []*kubejob.JobExecutor {
	mainExecs := make([]*kubejob.JobExecutor, 0, len(executors))
	for _, exec := range executors {
		if t.isMainExecutor(exec) {
			mainExecs = append(mainExecs, exec)
		}
	}
	return mainExecs
}

func (t *Task) sideCarExecutors(executors []*kubejob.JobExecutor) []*kubejob.JobExecutor {
	sideCarExecs := make([]*kubejob.JobExecutor, 0, len(executors))
	for _, exec := range executors {
		if !t.isMainExecutor(exec) {
			sideCarExecs = append(sideCarExecs, exec)
		}
	}
	return sideCarExecs
}

func (t *Task) isMainExecutor(exec *kubejob.JobExecutor) bool {
	return t.mainContainer(exec.Container)
}

func (t *Task) mainContainer(container corev1.Container) bool {
	return t.hasArtifact(container) || t.hasKeyEnv(container)
}

func (t *Task) hasArtifact(container corev1.Container) bool {
	_, exists := t.artifactContainerNames[container.Name]
	return exists
}

func (t *Task) hasKeyEnv(container corev1.Container) bool {
	if t.strategyKey == nil {
		return false
	}
	envName := t.strategyKey.Env
	for _, env := range container.Env {
		if env.Name == envName {
			return true
		}
	}
	return false
}

type TaskGroup struct {
	tasks []*Task
}

func NewTaskGroup(tasks []*Task) *TaskGroup {
	return &TaskGroup{
		tasks: tasks,
	}
}

func (g *TaskGroup) Run(ctx context.Context) error {
	var eg errgroup.Group
	for _, task := range g.tasks {
		task := task
		eg.Go(func() error {
			return task.Run(ctx)
		})
	}
	return eg.Wait()
}
