//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"sync"

	"golang.org/x/sync/errgroup"
	corev1 "k8s.io/api/core/v1"
)

type Task struct {
	job                    Job
	artifactContainerNames map[string]ArtifactSpec
	copyArtifact           func(JobExecutor) error
	strategyKey            *StrategyKey
}

func (t *Task) Run(ctx context.Context) (*TaskResult, error) {
	var result TaskResult
	if err := t.job.RunWithExecutionHandler(ctx, func(executors []JobExecutor) error {
		for _, sidecar := range t.sideCarExecutors(executors) {
			sidecar.ExecAsync()
		}
		subTasks := t.getSubTasks(t.mainExecutors(executors))
		if t.strategyKey == nil {
			group, err := NewSubTaskGroup(subTasks).Run(ctx)
			if err != nil {
				return err
			}
			result.add(group)
			return nil
		}
		for _, subTaskGroup := range t.strategyKey.SubTaskScheduler.Schedule(subTasks) {
			group, err := subTaskGroup.Run(ctx)
			if err != nil {
				return err
			}
			result.add(group)
		}
		return nil
	}); err != nil {
		return nil, err
	}
	return &result, nil
}

func (t *Task) getSubTasks(execs []JobExecutor) []*SubTask {
	tasks := make([]*SubTask, 0, len(execs))
	for _, exec := range execs {
		container := exec.Container()
		var envName string
		if t.strategyKey != nil {
			envName = t.strategyKey.Env
		}
		tasks = append(tasks, &SubTask{
			Name:         t.getKeyName(container),
			KeyEnvName:   envName,
			exec:         exec,
			hasArtifact:  t.hasArtifact(container),
			copyArtifact: t.copyArtifact,
		})
	}
	return tasks
}

func (t *Task) mainExecutors(executors []JobExecutor) []JobExecutor {
	if len(executors) == 1 {
		return executors
	}
	mainExecs := make([]JobExecutor, 0, len(executors))
	for _, exec := range executors {
		if t.isMainExecutor(exec) {
			mainExecs = append(mainExecs, exec)
		}
	}
	return mainExecs
}

func (t *Task) sideCarExecutors(executors []JobExecutor) []JobExecutor {
	if len(executors) == 1 {
		return nil
	}
	sideCarExecs := make([]JobExecutor, 0, len(executors))
	for _, exec := range executors {
		if !t.isMainExecutor(exec) {
			sideCarExecs = append(sideCarExecs, exec)
		}
	}
	return sideCarExecs
}

func (t *Task) isMainExecutor(exec JobExecutor) bool {
	return t.mainContainer(exec.Container())
}

func (t *Task) mainContainer(container corev1.Container) bool {
	return t.hasArtifact(container) || t.hasKeyEnv(container)
}

func (t *Task) hasArtifact(container corev1.Container) bool {
	_, exists := t.artifactContainerNames[container.Name]
	return exists
}

func (t *Task) getKeyName(container corev1.Container) string {
	if t.strategyKey == nil {
		return container.Name
	}
	envName := t.strategyKey.Env
	for _, env := range container.Env {
		if env.Name == envName {
			return env.Value
		}
	}
	return container.Name
}

func (t *Task) hasKeyEnv(container corev1.Container) bool {
	if t.strategyKey == nil {
		return false
	}
	envName := t.strategyKey.Env
	for _, env := range container.Env {
		if env.Name == envName {
			return true
		}
	}
	return false
}

type TaskGroup struct {
	tasks []*Task
}

func NewTaskGroup(tasks []*Task) *TaskGroup {
	return &TaskGroup{
		tasks: tasks,
	}
}

func (g *TaskGroup) Run(ctx context.Context) (*TaskResultGroup, error) {
	var (
		eg errgroup.Group
		rg TaskResultGroup
	)
	for _, task := range g.tasks {
		task := task
		eg.Go(func() error {
			result, err := task.Run(ctx)
			if err != nil {
				return err
			}
			rg.add(result)
			return nil
		})
	}
	if err := eg.Wait(); err != nil {
		return nil, err
	}
	return &rg, nil
}

type TaskResult struct {
	groups []*SubTaskResultGroup
}

func (r *TaskResult) add(group *SubTaskResultGroup) {
	r.groups = append(r.groups, group)
}

type TaskResultGroup struct {
	results []*TaskResult
	mu      sync.Mutex
}

func (g *TaskResultGroup) add(result *TaskResult) {
	g.mu.Lock()
	g.results = append(g.results, result)
	g.mu.Unlock()
}
