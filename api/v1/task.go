//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"encoding/json"
	"errors"
	"sync"

	"github.com/goccy/kubejob"
	"golang.org/x/sync/errgroup"
	corev1 "k8s.io/api/core/v1"
)

type Task struct {
	OnFinishSubTask   func(*SubTask)
	job               Job
	copyArtifact      func(context.Context, *SubTask) error
	strategyKey       *StrategyKey
	mainContainerName string
}

func (t *Task) Run(ctx context.Context) (*TaskResult, error) {
	var result TaskResult
	if err := t.job.RunWithExecutionHandler(ctx, func(executors []JobExecutor) error {
		for _, sidecar := range t.sideCarExecutors(executors) {
			sidecar.ExecAsync(ctx)
		}
		subTasks := t.getSubTasks(t.mainExecutors(executors))
		if t.strategyKey == nil {
			group, err := NewSubTaskGroup(subTasks).Run(ctx)
			if err != nil {
				return err
			}
			result.add(group)
			return nil
		}
		for _, subTaskGroup := range t.strategyKey.SubTaskScheduler.Schedule(subTasks) {
			group, err := subTaskGroup.Run(ctx)
			if err != nil {
				return err
			}
			result.add(group)
		}
		return nil
	}); err != nil {
		var failedJob *kubejob.FailedJob
		if !errors.As(err, &failedJob) {
			return nil, err
		}
		// ignore FailedJob error
	}
	return &result, nil
}

func (t *Task) getSubTasks(execs []JobExecutor) []*SubTask {
	tasks := make([]*SubTask, 0, len(execs))
	for _, exec := range execs {
		container := exec.Container()
		var envName string
		if t.strategyKey != nil {
			envName = t.strategyKey.Env
		}
		tasks = append(tasks, &SubTask{
			Name:         t.getKeyName(container),
			KeyEnvName:   envName,
			OnFinish:     t.OnFinishSubTask,
			exec:         exec,
			copyArtifact: t.copyArtifact,
			isMain:       t.isMainExecutor(exec),
		})
	}
	return tasks
}

func (t *Task) mainExecutors(executors []JobExecutor) []JobExecutor {
	mainExecs := make([]JobExecutor, 0, len(executors))
	for _, exec := range executors {
		if t.isMainExecutor(exec) {
			mainExecs = append(mainExecs, exec)
		}
	}
	return mainExecs
}

func (t *Task) sideCarExecutors(executors []JobExecutor) []JobExecutor {
	sideCarExecs := make([]JobExecutor, 0, len(executors))
	for _, exec := range executors {
		if !t.isMainExecutor(exec) {
			sideCarExecs = append(sideCarExecs, exec)
		}
	}
	return sideCarExecs
}

func (t *Task) isMainExecutor(exec JobExecutor) bool {
	return t.mainContainerName == exec.Container().Name || t.hasKeyEnv(exec.Container())
}

func (t *Task) getKeyName(container corev1.Container) string {
	if t.strategyKey == nil {
		return container.Name
	}
	envName := t.strategyKey.Env
	for _, env := range container.Env {
		if env.Name == envName {
			return env.Value
		}
	}
	return container.Name
}

func (t *Task) hasKeyEnv(container corev1.Container) bool {
	if t.strategyKey == nil {
		return false
	}
	envName := t.strategyKey.Env
	for _, env := range container.Env {
		if env.Name == envName {
			return true
		}
	}
	return false
}

type TaskGroup struct {
	tasks []*Task
}

func NewTaskGroup(tasks []*Task) *TaskGroup {
	return &TaskGroup{
		tasks: tasks,
	}
}

func (g *TaskGroup) Run(ctx context.Context) (*TaskResultGroup, error) {
	var (
		eg errgroup.Group
		rg TaskResultGroup
	)
	for _, task := range g.tasks {
		task := task
		eg.Go(func() error {
			result, err := task.Run(ctx)
			if err != nil {
				return err
			}
			rg.add(result)
			return nil
		})
	}
	if err := eg.Wait(); err != nil {
		return nil, err
	}
	return &rg, nil
}

type TaskResult struct {
	groups []*SubTaskResultGroup
}

func (r *TaskResult) MainTaskResults() []*SubTaskResult {
	mainResults := []*SubTaskResult{}
	for _, group := range r.groups {
		for _, result := range group.results {
			if result.IsMain {
				mainResults = append(mainResults, result)
			}
		}
	}
	return mainResults
}

func (r *TaskResult) add(group *SubTaskResultGroup) {
	r.groups = append(r.groups, group)
}

type TaskResultGroup struct {
	results []*TaskResult
	mu      sync.Mutex
}

func (g *TaskResultGroup) Status() ResultStatus {
	for _, result := range g.results {
		for _, group := range result.groups {
			for _, subTaskResult := range group.results {
				if err := subTaskResult.Error(); err != nil {
					return ResultStatusFailure
				}
			}
		}
	}
	return ResultStatusSuccess
}

func (g *TaskResultGroup) MarshalJSON() ([]byte, error) {
	type resultReport struct {
		Status         TaskResultStatus `json:"status"`
		Name           string           `json:"name"`
		ElapsedTimeSec int64            `json:"elapsedTimeSec"`
	}
	allResults := []*resultReport{}
	for _, result := range g.results {
		for _, group := range result.groups {
			for _, subTaskResult := range group.results {
				allResults = append(allResults, &resultReport{
					Status:         subTaskResult.Status,
					Name:           subTaskResult.Name,
					ElapsedTimeSec: int64(subTaskResult.ElapsedTime.Seconds()),
				})
			}
		}
	}
	return json.Marshal(allResults)
}

func (g *TaskResultGroup) add(result *TaskResult) {
	g.mu.Lock()
	g.results = append(g.results, result)
	g.mu.Unlock()
}
