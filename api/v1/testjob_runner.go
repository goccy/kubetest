//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

/*
import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/goccy/kubejob"
	"github.com/goccy/kubetest/internal/kubetest"
	"github.com/rs/xid"
	"golang.org/x/sync/errgroup"
	"golang.org/x/xerrors"
	batchv1 "k8s.io/api/batch/v1"
	apiv1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

var (
	ErrFailedTestJob = xerrors.New("failed test job")
	ErrFatal         = xerrors.New("fatal error")
)

type TestResult string

const (
	// TestResultSuccess represents that all test cases have passed.
	TestResultSuccess TestResult = "success"
	// TestResultFailure represents failed test case exists.
	TestResultFailure TestResult = "failure"
	// TestResultError is unexpected internal error.
	TestResultError TestResult = "error"
)

type TestJobRunner struct {
	tokenSecret        *apiv1.SecretKeySelector
	disabledPrepareLog bool
	disabledCommandLog bool
	disabledResultLog  bool
	verboseLog         bool
	logger             func(*kubejob.ContainerLog)
	config             *rest.Config
	clientSet          *kubernetes.Clientset
	logPrinter         *kubetest.Logger
	masks              []string
	testCountMu        sync.Mutex
	testCount          uint
	totalTestNum       uint
}

func NewTestJobRunner(config *rest.Config) (*TestJobRunner, error) {
	cs, err := kubernetes.NewForConfig(config)
	if err != nil {
		return nil, xerrors.Errorf("failed to create clientset: %w", err)
	}
	return &TestJobRunner{
		config:     config,
		clientSet:  cs,
		logPrinter: kubetest.NewLogger(),
	}, nil
}

func (r *TestJobRunner) Run(ctx context.Context, testjob TestJob) error {
	if err := testjob.validate(); err != nil {
		return xerrors.Errorf("validate error: %w", err)
	}
	testLog := TestResultLog{Job: testjob.ObjectMeta.Name, StartedAt: time.Now()}

	defer func(start time.Time) {
		if r.disabledResultLog {
			return
		}
		testLog.ElapsedTimeSec = int(time.Since(start).Seconds())
		b, _ := json.Marshal(testLog)

		var logMap map[string]interface{}
		json.Unmarshal(b, &logMap)

		for k, v := range testjob.Spec.Log.ExtParam {
			logMap[k] = v
		}
		b, _ = json.Marshal(logMap)
		fmt.Println(string(b))
	}(time.Now())

	testLogs, err := r.run(ctx, testjob)
	testLog.Details = TestResultLogDetail{
		Tests: testLogs,
	}
	if err != nil {
		if xerrors.Is(err, ErrFatal) {
			testLog.TestResult = TestResultError
		} else {
			testLog.TestResult = TestResultFailure
		}
		return err
	}
	testLog.TestResult = TestResultSuccess
	return nil
}

func (r *TestJobRunner) validateTestLogs(tests []string, testlogs []*TestLog) error {
	testLogMap := map[string]struct{}{}
	for _, log := range testlogs {
		testLogMap[log.Name] = struct{}{}
	}
	invalidTests := []string{}
	for _, test := range tests {
		if _, exists := testLogMap[test]; exists {
			continue
		}
		invalidTests = append(invalidTests, test)
	}
	if len(invalidTests) > 0 {
		return xerrors.Errorf("failed to find [ %s ] test logs: %w", strings.Join(invalidTests, ","), ErrFatal)
	}
	return nil
}

func (r *TestJobRunner) runDistributedTest(ctx context.Context, testjob TestJob) ([]*TestLog, error) {
	r.totalTestNum = uint(len(list))
	if err := r.validateTestLogs(list, testLogs); err != nil {
		return nil, xerrors.Errorf("invalid testlogs: %w", err)
	}
	if len(failedTestLogs) > 0 {
		if !testjob.enabledRetest() {
			return testLogs, ErrFailedTestJob
		}
		return r.retest(ctx, testjob, testLogs, failedTestLogs)
	}
	return testLogs, nil
}

func (r *TestJobRunner) syncArtifactsIfNeeded(testjob TestJob, executor *kubejob.JobExecutor, testName string) error {
	if testjob.Spec.DistributedTest.Artifacts == nil {
		return nil
	}
	artifacts := testjob.Spec.DistributedTest.Artifacts

	var intermediateDir string
	switch artifacts.Output.PathType {
	case ArtifactOutputPathContainer:
		intermediateDir = executor.Container.Name
	case ArtifactOutputPathTest:
		intermediateDir = testName
	default:
		intermediateDir = executor.Container.Name
	}
	outputDir := filepath.Join(artifacts.Output.Path, intermediateDir)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return xerrors.Errorf("failed to create directory %s: %w", outputDir, err)
	}

	for _, path := range artifacts.Paths {
		var src string
		if filepath.IsAbs(path) {
			src = path
		} else {
			src = filepath.Join(executor.Container.WorkingDir, path)
		}
		r.logPrinter.DebugLog(fmt.Sprintf("copy %s's result file to %s", testName, outputDir))
		if err := r.copyTextFileWithRetry(executor, src, outputDir); err != nil {
			return xerrors.Errorf("failed to copy %s result from %s to %s: %w", testName, src, outputDir, err)
		}
	}
	return nil
}
*/
