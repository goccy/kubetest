//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"fmt"

	"github.com/goccy/kubejob"
	"golang.org/x/sync/errgroup"
)

type SubTask struct {
	exec         *kubejob.JobExecutor
	hasArtifact  bool
	copyArtifact func(*kubejob.JobExecutor) error
}

type TaskResultStatus int

const (
	TaskResultSuccess TaskResultStatus = iota
	TaskResultFailure
)

type SubTaskResult struct {
	Status TaskResultStatus
}

func (t *SubTask) Run(ctx context.Context) (*SubTaskResult, error) {
	defer func() {
		if err := t.exec.Stop(); err != nil {
			fmt.Printf("failed to stop %s", err)
		}
	}()
	result := &SubTaskResult{}
	out, err := t.exec.ExecOnly()
	fmt.Println("out = ", string(out))
	if err == nil {
		result.Status = TaskResultSuccess
	} else {
		result.Status = TaskResultFailure
	}
	if t.hasArtifact {
		if err := t.copyArtifact(t.exec); err != nil {
			result.Status = TaskResultFailure
		}
	}
	return result, nil
}

type SubTaskGroup struct {
	tasks []*SubTask
}

func NewSubTaskGroup(tasks []*SubTask) *SubTaskGroup {
	return &SubTaskGroup{
		tasks: tasks,
	}
}

func (g *SubTaskGroup) Run(ctx context.Context) error {
	var eg errgroup.Group
	for _, task := range g.tasks {
		task := task
		eg.Go(func() error {
			result, err := task.Run(ctx)
			if err != nil {
				return err
			}
			fmt.Println("subtask result = ", result)
			return nil
		})
	}
	return eg.Wait()
}
