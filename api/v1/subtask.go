//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"context"
	"fmt"
	"sync"

	"golang.org/x/sync/errgroup"
	corev1 "k8s.io/api/core/v1"
)

type SubTask struct {
	Name         string
	exec         JobExecutor
	hasArtifact  bool
	copyArtifact func(JobExecutor) error
}

func (t *SubTask) Run(ctx context.Context) (*SubTaskResult, error) {
	defer func() {
		if err := t.exec.Stop(); err != nil {
			fmt.Printf("failed to stop %s", err)
		}
	}()
	out, err := t.exec.ExecOnly()
	result := &SubTaskResult{
		Out:       out,
		Err:       err,
		Name:      t.Name,
		Container: t.exec.Container(),
		Pod:       t.exec.Pod(),
	}
	if err == nil {
		result.Status = TaskResultSuccess
	} else {
		result.Status = TaskResultFailure
	}
	if t.hasArtifact {
		if err := t.copyArtifact(t.exec); err != nil {
			result.Status = TaskResultFailure
			result.ArtifactErr = err
		}
	}
	return result, nil
}

type SubTaskGroup struct {
	tasks []*SubTask
}

func NewSubTaskGroup(tasks []*SubTask) *SubTaskGroup {
	return &SubTaskGroup{
		tasks: tasks,
	}
}

func (g *SubTaskGroup) Run(ctx context.Context) (*SubTaskResultGroup, error) {
	var (
		eg errgroup.Group
		rg SubTaskResultGroup
	)
	for _, task := range g.tasks {
		task := task
		eg.Go(func() error {
			result, err := task.Run(ctx)
			if err != nil {
				return err
			}
			rg.add(result)
			return nil
		})
	}
	if err := eg.Wait(); err != nil {
		return nil, err
	}
	return &rg, nil
}

type TaskResultStatus int

const (
	TaskResultSuccess TaskResultStatus = iota
	TaskResultFailure
)

type SubTaskResult struct {
	Status      TaskResultStatus
	Out         []byte
	Err         error
	ArtifactErr error
	Name        string
	Container   corev1.Container
	Pod         *corev1.Pod
}

type SubTaskResultGroup struct {
	results []*SubTaskResult
	mu      sync.Mutex
}

func (g *SubTaskResultGroup) add(result *SubTaskResult) {
	g.mu.Lock()
	g.results = append(g.results, result)
	g.mu.Unlock()
}
