//go:build !ignore_autogenerated
// +build !ignore_autogenerated

package v1

import (
	"fmt"
)

type Validator struct {
	tokenNameMap    map[string]struct{}
	repoNameMap     map[string]struct{}
	artifactNameMap map[string]struct{}
}

func NewValidator() *Validator {
	return &Validator{
		tokenNameMap:    map[string]struct{}{},
		repoNameMap:     map[string]struct{}{},
		artifactNameMap: map[string]struct{}{},
	}
}

func (v *Validator) ValidateTestJob(job TestJob) error {
	if err := v.ValidateTestJobSpec(job.Spec); err != nil {
		return err
	}
	return nil
}

func (v *Validator) ValidateTestJobSpec(spec TestJobSpec) error {
	if err := v.ValidateLog(spec.Log); err != nil {
		return err
	}
	for _, token := range spec.Tokens {
		if err := v.ValidateToken(token); err != nil {
			return err
		}
		if _, exists := v.tokenNameMap[token.Name]; exists {
			return fmt.Errorf("kubetest: specified token name '%s' is duplicated", token.Name)
		}
		v.tokenNameMap[token.Name] = struct{}{}
	}
	for _, repo := range spec.Repos {
		if err := v.ValidateRepositorySpec(repo); err != nil {
			return err
		}
		if _, exists := v.repoNameMap[repo.Name]; exists {
			return fmt.Errorf("kubetest: specified repository name '%s' is duplicated", repo.Name)
		}
		v.repoNameMap[repo.Name] = struct{}{}
	}
	for _, prestep := range spec.PreSteps {
		if err := v.ValidatePreStep(prestep); err != nil {
			return err
		}
	}
	if err := v.ValidateMainStep(spec.MainStep); err != nil {
		return err
	}
	for _, poststep := range spec.PostSteps {
		if err := v.ValidatePostStep(poststep); err != nil {
			return err
		}
	}
	for _, artifact := range spec.ExportArtifacts {
		if err := v.ValidateExportArtifact(artifact); err != nil {
			return err
		}
	}
	return nil
}

func (v *Validator) ValidateLog(spec LogSpec) error {
	if spec.Level != LogLevelNone {
		switch spec.Level {
		case LogLevelDebug, LogLevelInfo, LogLevelWarn, LogLevelError:
		default:
			return fmt.Errorf("kubetest: unknown log level %d", spec.Level)
		}
	}
	return nil
}

func (v *Validator) ValidateToken(token TokenSpec) error {
	if token.Name == "" {
		return fmt.Errorf("kubetest: token name must be specified")
	}
	if token.Value.GitHubApp == nil && token.Value.GitHubToken == nil {
		return fmt.Errorf("kubetest: githubApp or githubToken must be specified")
	}
	if token.Value.GitHubApp != nil && token.Value.GitHubToken != nil {
		return fmt.Errorf("kubetest: only one of githubApp or githubToken needs to be specified")
	}
	switch {
	case token.Value.GitHubApp != nil:
		return v.ValidateGitHubAppTokenSource(token.Value.GitHubApp)
	case token.Value.GitHubToken != nil:
		return v.ValidateGitHubTokenSource(token.Value.GitHubToken)
	}
	return nil
}

func (v *Validator) ValidateGitHubAppTokenSource(source *GitHubAppTokenSource) error {
	if source.KeyFile == nil {
		return fmt.Errorf("kubetest: githubApp.keyFile must be specified")
	}
	if source.AppID == 0 {
		return fmt.Errorf("kubetest: githubApp.appId must be specified")
	}
	if source.Organization == "" && source.InstallationID == 0 {
		return fmt.Errorf("kubetest: githubApp.organization or githubApp.installationId must be specified")
	}
	return nil
}

func (v *Validator) ValidateGitHubTokenSource(source *GitHubTokenSource) error {
	if source.Name == "" {
		return fmt.Errorf("kubetest: githubToken.name must be specified")
	}
	if source.Key == "" {
		return fmt.Errorf("kubetest: githubToken.key must be specified")
	}
	return nil
}

func (v *Validator) ValidateRepositorySpec(spec RepositorySpec) error {
	if spec.Name == "" {
		return fmt.Errorf("kubetest: repository name must be specified")
	}
	if err := v.ValidateRepository(spec.Value); err != nil {
		return err
	}
	return nil
}

func (v *Validator) ValidateRepository(repo Repository) error {
	if repo.URL == "" {
		return fmt.Errorf("kubetest: repository url must be specified")
	}
	if repo.Token != "" {
		if _, exists := v.tokenNameMap[repo.Token]; !exists {
			return fmt.Errorf("kubetest: repository token name %s is undefined", repo.Token)
		}
	}
	if repo.Branch != "" && repo.Rev != "" {
		return fmt.Errorf("kubetest: only one of repository branch or rev needs to be specified")
	}
	return nil
}

func (v *Validator) ValidatePreStep(prestep PreStep) error {
	if prestep.Name == "" {
		return fmt.Errorf("kubetest: prestep name must be specified")
	}
	if err := v.ValidateTestJobTemplateSpec(prestep.Template, PreStepType); err != nil {
		return err
	}
	return nil
}

func (v *Validator) ValidateMainStep(step MainStep) error {
	if err := v.ValidateStrategy(step.Strategy); err != nil {
		return err
	}
	if err := v.ValidateTestJobTemplateSpec(step.Template, MainStepType); err != nil {
		return err
	}
	return nil
}

func (v *Validator) ValidatePostStep(poststep PostStep) error {
	if poststep.Name == "" {
		return fmt.Errorf("kubetest: poststep name must be specified")
	}
	if err := v.ValidateTestJobTemplateSpec(poststep.Template, PostStepType); err != nil {
		return err
	}
	return nil
}

func (v *Validator) ValidateTestJobTemplateSpec(spec TestJobTemplateSpec, stepType StepType) error {
	if len(spec.Spec.Containers) > 1 && spec.Main == "" {
		return fmt.Errorf("kubetest: if specified multiple containers, must be specified template.main param for the main container")
	}
	if err := v.ValidateTestJobPodSpec(spec.Spec, stepType); err != nil {
		return err
	}
	return nil
}

func (v *Validator) ValidateTestJobPodSpec(spec TestJobPodSpec, stepType StepType) error {
	if len(spec.PodSpec.Containers) == 0 {
		return fmt.Errorf("kubetest: template.spec.containers are must be specified")
	}
	for _, container := range spec.PodSpec.InitContainers {
		if len(container.Command) == 0 {
			return fmt.Errorf("kubetest: template.spec.initContainers[].command must be specified")
		}
		if container.Image == "" {
			return fmt.Errorf("kubetest: template.spec.initContainers[].image must be specified")
		}
	}
	for _, container := range spec.PodSpec.Containers {
		if len(container.Command) == 0 {
			return fmt.Errorf("kubetest: template.spec.containers[].command must be specified")
		}
		if container.Image == "" {
			return fmt.Errorf("kubetest: template.spec.containers[].image must be specified")
		}
	}
	for _, volume := range spec.Volumes {
		if err := v.ValidateTestJobVolume(volume, stepType); err != nil {
			return err
		}
	}
	for _, artifact := range spec.Artifacts {
		if err := v.ValidateArtifactSpec(artifact); err != nil {
			return err
		}
		var foundContainerName bool
		for _, container := range spec.PodSpec.Containers {
			if container.Name == artifact.Container.Name {
				foundContainerName = true
				break
			}
		}
		if !foundContainerName {
			return fmt.Errorf("kubetest: template.spec.artifact.container.name %s is undefined", artifact.Container.Name)
		}
		if _, exists := v.artifactNameMap[artifact.Name]; exists {
			return fmt.Errorf("kubetest: specified artifact name '%s' is duplicated", artifact.Name)
		}
		v.artifactNameMap[artifact.Name] = struct{}{}
	}
	return nil
}

func (v *Validator) ValidateArtifactSpec(spec ArtifactSpec) error {
	if spec.Name == "" {
		return fmt.Errorf("kubetest: template.spec.artifact.name must be specified")
	}
	if err := v.ValidateArtifactContainer(spec.Container); err != nil {
		return err
	}
	return nil
}

func (v *Validator) ValidateArtifactContainer(container ArtifactContainer) error {
	if container.Name == "" {
		return fmt.Errorf("kubetest: template.spec.artifact.container.name must be specified")
	}
	if container.Path == "" {
		return fmt.Errorf("kubetest: template.spec.artifact.container.path must be specified")
	}
	return nil
}

func (v *Validator) ValidateTestJobVolume(volume TestJobVolume, stepType StepType) error {
	if volume.Name == "" {
		return fmt.Errorf("kubetest: volume name must be specified")
	}
	if err := v.ValidateTestJobVolumeSource(volume.TestJobVolumeSource, stepType); err != nil {
		return err
	}
	return nil
}

func (v *Validator) ValidateTestJobVolumeSource(source TestJobVolumeSource, stepType StepType) error {
	switch {
	case source.Repo != nil:
		return v.ValidateRepositoryVolumeSource(source.Repo)
	case source.Artifact != nil:
		return v.ValidateArtifactVolumeSource(source.Artifact)
	case source.Token != nil:
		return v.ValidateTokenVolumeSource(source.Token)
	case source.Log != nil:
		return v.ValidateLogVolumeSource(stepType)
	case source.Report != nil:
		return v.ValidateReportVolumeSource(source.Report, stepType)
	}
	return nil
}

func (v *Validator) ValidateRepositoryVolumeSource(source *RepositoryVolumeSource) error {
	if source.Name == "" {
		return fmt.Errorf("kubetest: repository volume source name must be specified")
	}
	if _, exists := v.repoNameMap[source.Name]; !exists {
		return fmt.Errorf("kubetest: repository volume source name %s is undefined", source.Name)
	}
	return nil
}

func (v *Validator) ValidateArtifactVolumeSource(source *ArtifactVolumeSource) error {
	if source.Name == "" {
		return fmt.Errorf("kubetest: artifact volume source name must be specified")
	}
	if _, exists := v.artifactNameMap[source.Name]; !exists {
		return fmt.Errorf("kubetest: artifact volume source name %s is undefined", source.Name)
	}
	return nil
}

func (v *Validator) ValidateTokenVolumeSource(source *TokenVolumeSource) error {
	if source.Name == "" {
		return fmt.Errorf("kubetest: token volume source name must be specified")
	}
	if _, exists := v.tokenNameMap[source.Name]; !exists {
		return fmt.Errorf("kubetest: token volume source name %s is undefined", source.Name)
	}
	return nil
}

func (v *Validator) ValidateLogVolumeSource(stepType StepType) error {
	if stepType != PostStepType {
		return fmt.Errorf("kubetest: log volume source must be specified postSteps only")
	}
	return nil
}

func (v *Validator) ValidateReportVolumeSource(report *ReportVolumeSource, stepType StepType) error {
	if stepType != PostStepType {
		return fmt.Errorf("kubetest: report volume source must be specified postSteps only")
	}
	switch report.Format {
	case ReportFormatTypeJSON:
		return nil
	default:
		return fmt.Errorf("kubetest: unknown report format %s", report.Format)
	}
}

func (v *Validator) ValidateStrategy(strategy *Strategy) error {
	if strategy == nil {
		return nil
	}
	if err := v.ValidateStrategyKeySpec(strategy.Key); err != nil {
		return err
	}
	if err := v.ValidateScheduler(strategy.Scheduler); err != nil {
		return err
	}
	return nil
}

func (v *Validator) ValidateStrategyKeySpec(spec StrategyKeySpec) error {
	if spec.Env == "" {
		return fmt.Errorf("kubetest: strategy.key.env must be specified")
	}
	if err := v.ValidateStrategyKeySource(spec.Source); err != nil {
		return err
	}
	return nil
}

func (v *Validator) ValidateStrategyKeySource(source StrategyKeySource) error {
	if len(source.Static) == 0 && source.Dynamic == nil {
		return fmt.Errorf("kubetest: strategy.key.source.static or strategy.key.source.dynamic must be specified")
	}
	if len(source.Static) > 0 && source.Dynamic != nil {
		return fmt.Errorf("kubetest: only one of strategy.key.source.static or strategy.key.source.dynamic needs to be specified")
	}
	if source.Dynamic != nil {
		return v.ValidateStrategyDynamicKeySource(source.Dynamic)
	}
	return nil
}

func (v *Validator) ValidateStrategyDynamicKeySource(source *StrategyDynamicKeySource) error {
	if err := v.ValidateTestJobTemplateSpec(source.Template, MainStepType); err != nil {
		return err
	}
	return nil
}

func (v *Validator) ValidateScheduler(scheduler Scheduler) error {
	if scheduler.MaxContainersPerPod == 0 {
		return fmt.Errorf("kubetest: strategy.scheduler.maxContainersPerPod must be specified")
	}
	if scheduler.MaxConcurrentNumPerPod == 0 {
		return fmt.Errorf("kubetest: strategy.scheduler.maxConcurrentNumPerPod must be specified")
	}
	return nil
}

func (v *Validator) ValidateExportArtifact(artifact ExportArtifact) error {
	if artifact.Name == "" {
		return fmt.Errorf("kubetest: exportArtifact.name must be specified")
	}
	if _, exists := v.artifactNameMap[artifact.Name]; !exists {
		return fmt.Errorf("kubetest: export artifact name %s is undefined", artifact.Name)
	}
	if artifact.Path == "" {
		return fmt.Errorf("kubetest: exportArtifact.path must be specified")
	}
	return nil
}
